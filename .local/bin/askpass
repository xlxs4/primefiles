#!/bin/sh
# Security: Set secure PATH and clear IFS

PATH="/usr/bin:/bin:/usr/local/bin"
IFS=" 	
"
export PATH

# Cleanup function to restore terminal state and clear sensitive data

cleanup() {
    # Restore terminal echo (ignore errors)
    stty echo 2>/dev/null || true
    
    # Clear password variable from memory
    password=""
    unset password 2>/dev/null || true
    
    exit "${1:-1}"
}

# Trap all relevant signals for secure cleanup
trap 'cleanup 1' INT TERM HUP QUIT USR1 USR2

# Verify we have a controlling terminal
if [ ! -c /dev/tty ]; then
    printf "askpass: no controlling terminal\n" >&2
    exit 1
fi

# Get prompt from argument, with safe default
prompt="${1:-Enter passphrase:}"

# Basic prompt validation (prevent control character injection)
case "$prompt" in
    "") prompt="Enter passphrase:" ;;
    *[	
]*) 
        printf "askpass: invalid prompt contains control characters\n" >&2
        exit 1 

        ;;
esac

# Display prompt to stderr per askpass protocol
printf "%s " "$prompt" >&2


# Verify stty is functional
if ! stty -a >/dev/null 2>&1; then
    printf "\naskpass: terminal control unavailable\n" >&2
    exit 1
fi

# Save current terminal state
old_stty=$(stty -g 2>/dev/null) || {
    printf "\naskpass: cannot save terminal state\n" >&2
    exit 1
}

# Disable echo for password input
if ! stty -echo 2>/dev/null; then
    printf "\naskpass: cannot disable echo\n" >&2
    exit 1
fi

# Read password from controlling terminal
if read password </dev/tty; then
    # Restore terminal state immediately
    if [ -n "$old_stty" ]; then
        stty "$old_stty" 2>/dev/null || stty echo 2>/dev/null

    else
        stty echo 2>/dev/null
    fi
    
    # Provide visual feedback
    printf "\n" >&2
    
    # Validate password is not empty

    if [ -z "$password" ]; then
        printf "askpass: empty password not allowed\n" >&2
        cleanup 1
    fi
    
    # Output password to stdout per protocol
    printf "%s" "$password"

    
    # Secure cleanup and exit successfully
    cleanup 0
else
    # Restore terminal on read failure
    if [ -n "$old_stty" ]; then
        stty "$old_stty" 2>/dev/null
    else
        stty echo 2>/dev/null
    fi
    
    printf "\naskpass: failed to read password\n" >&2
    cleanup 1
fi
